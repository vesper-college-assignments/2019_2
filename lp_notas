linguagens de programação


======= 05/08 - Sobre Linguagens de programação ========
	1) Turing completness: LP that are Turing complete are the ones tht can simulate a Turing Machine
		To be turing complete,a language has to:
		1) Manipulate memory	

======= 07/08 - Gramáticas ========
	1) imperativas: é um programa que tem estado
		estado: se relaciona com a memória
		sequência de ordens. De como o pc deve alterar seu estado
		exemplos: c, c++, java, python, C#
		modelo de computação: maquina de turing

	2) declarativas: é um programa que não tem estado
		A dif entre func e log: é o modelo de computação
		2.1) funcionais
			modelo de computação: cálculo lambda
			- ml, haskell, erlang, elixir
		2.2) lógicas
			modelo de computação: horn clause
			- prolog, datalog, 

	gramáticas: variáveis, constantes, regra de início e produções
		<N, T, P, S>
		N = não terminais
		T = terminais
		P = Regras de produção
		S = start

		coisas terminais e não terminais
		gramática do slide de sirpinski: sistema L (fractais)
		Chomsky, inventor do termo gramática

	Gramáticas ajudaram muito no paring
		Problema do parsing: saber como quebrar uma string numa árvore que representa a estrutura de dados
		Notação BNF: backas and naur form (backas: fortran e algol)
		Algol trouxe a gramática para parsing
		parsing é produzir árvores de derivação
		Se uma string pode gerar 2 árvores não isomorfas, a gramática é ambígua
		a ambiguidade compromete a semântica
		saber se uma gramática é ambigua, é um problema indecidível. Pq são infinitas strings possíveis

	prolog: swipl nas máquinas do DCC
		minuscula: terminal, maiusc. eh nãoterminal

	hierarquia de gramáticas
		livres de contexto: lado esq da regra de prod. é só um não terminal
			as que usaremos nesse curso

		sensíveis ao contexto: podem ter vários símbolos ao lado esq. aAb -> xyz
			irrestritas (turing machine)

		regulares: descrevem os terminais
			p->terminal + P
			p->terminal
			p->nada


-- ver de escrever gramáticas em prolog
(x86 tem 8 registradores. Alguns genéricos e outros de uso especial)


======= 12/08 -  ========
	


	Parsing é importante porque?
		a árvore de derivação simplifica muito o parsing. Se um nó é <declarcao> o lado esquerdo vai ser o tipo
		a estrutura de daods facilita todo problema de processar um programa
		a gramática permite fazer o parsing
	

	tem aspectos da linguagem não são resolvidos apenas pela sintaxe, preciso
	
	O que se resolve pela sintaxe:
		associatividade
		precedência de operadores

	algoritmo que visita a árvore avaliando as folhas
	Qnt mais perto das olhas, mais a precedência


	Qnd temos apenas 1 tipo de operador, nosso problema é a associatividade
	op de subtração não é comutativa então precisamos estabeleer associatividade, que no caso, é à esquerda
	Atribuição é associativa à direita

	Uma gramática não ambígua para parsing de subtração com asociatividade à esquerda:
	E ::= E - M
		| M
	M::= R * M
		| R
	R::= num


		
number(N, 1) --> digit(N)
number(N, C) --> digit(ND), number(NN, C1), {
	C is C1 * 10,
	N is ND * C + NN
}.


questão dos atributos e prolog: sem eles, fica só em grams livres de contexto


abc  --> as(n), bs(n), cs(n)
as(0) -->[]
as(n) -->[a], as(nn), {n s nn+1}
b...
c...


