linguagens de programação


======= 05/08 - Sobre Linguagens de programação ========
	1) Turing completness: LP that are Turing complete are the ones tht can simulate a Turing Machine
		To be turing complete,a language has to:
		1) Manipulate memory	

======= 07/08 - Gramáticas ========
	1) imperativas: é um programa que tem estado
		estado: se relaciona com a memória
		sequência de ordens. De como o pc deve alterar seu estado
		exemplos: c, c++, java, python, C#
		modelo de computação: maquina de turing

	2) declarativas: é um programa que não tem estado
		A dif entre func e log: é o modelo de computação
		2.1) funcionais
			modelo de computação: cálculo lambda
			- ml, haskell, erlang, elixir
		2.2) lógicas
			modelo de computação: horn clause
			- prolog, datalog, 

	gramáticas: variáveis, constantes, regra de início e produções
		<N, T, P, S>
		N = não terminais
		T = terminais
		P = Regras de produção
		S = start

		coisas terminais e não terminais
		gramática do slide de sirpinski: sistema L (fractais)
		Chomsky, inventor do termo gramática

	Gramáticas ajudaram muito no paring
		Problema do parsing: saber como quebrar uma string numa árvore que representa a estrutura de dados
		Notação BNF: backas and naur form (backas: fortran e algol)
		Algol trouxe a gramática para parsing
		parsing é produzir árvores de derivação
		Se uma string pode gerar 2 árvores não isomorfas, a gramática é ambígua
		a ambiguidade compromete a semântica
		saber se uma gramática é ambigua, é um problema indecidível. Pq são infinitas strings possíveis

	prolog: swipl nas máquinas do DCC
		minuscula: terminal, maiusc. eh nãoterminal

	hierarquia de gramáticas
		livres de contexto: lado esq da regra de prod. é só um não terminal
			as que usaremos nesse curso

		sensíveis ao contexto: podem ter vários símbolos ao lado esq. aAb -> xyz
			irrestritas (turing machine)

		regulares: descrevem os terminais
			p->terminal + P
			p->terminal
			p->nada


-- ver de escrever gramáticas em prolog
(x86 tem 8 registradores. Alguns genéricos e outros de uso especial)


======= 12/08 -  ========
	


	Parsing é importante porque?
		a árvore de derivação simplifica muito o parsing. Se um nó é <declarcao> o lado esquerdo vai ser o tipo
		a estrutura de daods facilita todo problema de processar um programa
		a gramática permite fazer o parsing
	

	tem aspectos da linguagem não são resolvidos apenas pela sintaxe, preciso
	
	O que se resolve pela sintaxe:
		associatividade
		precedência de operadores

	algoritmo que visita a árvore avaliando as folhas
	Qnt mais perto das olhas, mais a precedência


	Qnd temos apenas 1 tipo de operador, nosso problema é a associatividade
	op de subtração não é comutativa então precisamos estabeleer associatividade, que no caso, é à esquerda
	Atribuição é associativa à direita

	Uma gramática não ambígua para parsing de subtração com asociatividade à esquerda:
	E ::= E - M
		| M
	M::= R * M
		| R
	R::= num


		
number(N, 1) --> digit(N)
number(N, C) --> digit(ND), number(NN, C1), {
	C is C1 * 10,
	N is ND * C + NN
}.


questão dos atributos e prolog: sem eles, fica só em grams livres de contexto


abc  --> as(n), bs(n), cs(n)
as(0) -->[]
as(n) -->[a], as(nn), {n is nn+1}
b...s
c...





==== 14/08 - ==============================

	- compilar, interpretar, virtualizar
	- virtualizar (python): compila pra bytecode, interpreta o bytecode
		- máquins virtuais:jvm, clr, zend, cpython
		- cada navegador tem sua VM de js (Chrome: v8; firefox:spiderMonkey, safari: jsCore (ou webKit))
		- JVM interpeta várias linguagens: JAva, Kotlin, Groovy, Closure, Scala
		....
	- Pq das diferenças? Compiladas são mais eficientes
		- site the benchmark game
		- Eficiência
		- Se T = P + X
			- compilar é bo quando X é grande. Faz uma vez e pronto
			- interpretaré bom para applications e scripts de protótipos
				compilada  virt   inter AST
			P     G         M      P
			X     P         M      G
			* AST = ?
		- Executar o bytecode usufrui de localidade e por isso é mais rápido do que percorrer uma árvore

	Compilação de um programa C
	source -> [preprocessar] -> source ASCII -> [compilador] -> Assembly ASCII -> [montador] -> .obj -> [linker] -> .exe -> [loader] -> \o/
	[prof mostrou a compilação passo a passo]
	|?| identidades aritméticas no GCC
	o printf fica numa biblioteca dinamicamente compartilhada - GLIBC 
		Arquivos dessas libs tem extensões .so(Linux) .dll(windows) .dylib(Mac)
		O loader resolve isso em tempo de execução 
	comandos em bash estão na lib binutils (implementado em C)

	Vantagens da virtualização
	|?| OLhar com mais detalhe
		- cod binario de um ling compilada não é portável
		- o bytecode de uma VM é

	[prof demonstrou virtualização]
	- tempo de ligação de um programa C é em tepo de compilação. Só sabemos se uma varé int mesmo qnd compila
	- em python, por exemplo, é em execução

	- o tamanho de um int em java fidefinido em tempo de definição da linguagem
	- Em C,é definido em tempo de implementação da linguagem

	- diferentes coisas são conhecidas em diferentes tempos, para diferentes linguagens


	

